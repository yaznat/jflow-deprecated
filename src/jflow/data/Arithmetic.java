package jflow.data;

import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

class Arithmetic {
    /**
     * Multiply an array with a scalar.
     * @param input                 the array with values to multiply.
     * @param scalar                the scalar value to multiply with.
     * @param result                the array to populate with resulting values.
     */
    protected static void scalarMultiply(float[] input, float scalar, float[] result) {
        int length = input.length;

        IntStream.range(0, length).parallel().forEach(i -> {
            result[i] = input[i] * scalar;
        });
    }

    /**
     * Divide an array by a scalar.
     * @param input                 the array with values to divide.
     * @param scalar                the scalar value to divide by.
     * @param result                the array to populate with resulting values.
     */
    protected static void scalarDivide(float[] input, float scalar, float[] result) {
        int length = input.length;

        IntStream.range(0, length).parallel().forEach(i -> {
            result[i] = input[i] / scalar;
        });
    }

    /**
     * Add a scalar to an array.
     * @param input                 the array with values to add to.
     * @param scalar                the scalar value to add.
     * @param result                the array to populate with resulting values.
     */
    protected static void scalarAdd(float[] input, float scalar, float[] result) {
        int length = input.length;

        IntStream.range(0, length).parallel().forEach(i -> {
            result[i] = input[i] + scalar;
        });
    }

    /**
     * Subtract a scalar from an array.
     * @param input                 the array with values to subtract from.
     * @param scalar                the scalar value to subtract.
     * @param result                the array to populate with resulting values.
     */
    protected static void scalarSubtract(float[] input, float scalar, float[] result) {
        int length = input.length;

        IntStream.range(0, length).parallel().forEach(i -> {
            result[i] = input[i] - scalar;
        });
    }

    /**
     * Broadcast add an adder array with a base array.
     * @param base                  the 4D base array.
     * @param adder                 the array to broadcast over <b>base</b>.
     * All non-broadcast dimensions in <b>adder</b> should be one, e.g. (N,1,1,1) over (N,C,H,W)
     * @param shape                 the 4D shape of <b>base</b>.
     * @param result                the array to populate with resulting values.
     * @param broadcastDims         the dimension(s) to broadcast over. 
     */
    // NOTE: THIS FUNCTION IS PARTIALLY GENERATED BY CLAUDE.AI
    protected static void broadcastAdd(
        float[] base, 
        float[] adder, 
        int[] shape, 
        float[] result,
        int... broadcastDims
    ) {
        int numDims = 4;
        if (shape.length != numDims) {
            throw new IllegalArgumentException(
                "Incorrect length of shape. Expected: " 
                + numDims + ". Got: " + shape.length);
        }   
        int numElements = shape[0] * shape[1] * shape[2] * shape[3];
        
        Set<Integer> broadcastSet = Arrays
            .stream(broadcastDims)
            .boxed()
            .collect(Collectors.toSet());
        
        // Calculate strides for base array
        int[] strides = new int[numDims];
        strides[numDims - 1] = 1;
        for (int i = numDims - 2; i >= 0; i--) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        
        // Calculate strides for adder (0 for non-broadcast dims)
        int[] aStrides = new int[numDims];
        aStrides[numDims - 1] = broadcastSet.contains(numDims - 1) ? 1 : 0;
        for (int i = numDims - 2; i >= 0; i--) {
            aStrides[i] = broadcastSet.contains(i) ? 
                aStrides[i + 1] * (broadcastSet.contains(i + 1) ? shape[i + 1] : 1) : 0;
        }
        
        IntStream.range(0, numElements).parallel().forEach(flatIdx -> {
            int aIdx = 0, remaining = flatIdx;
            for (int i = 0; i < numDims; i++) {
                int idx = remaining / strides[i];
                aIdx += idx * aStrides[i];
                remaining %= strides[i];
            }
            result[flatIdx] = base[flatIdx] + adder[aIdx];
        });
    }

    /**
     * Broadcast subtract a subtractor array from a base array.
     * @param base                  the 4D base array.
     * @param subtractor            the array to broadcast over <b>base</b>.
     * All non-broadcast dimensions in <b>subtractor</b> should be one, e.g. (N,1,1,1) over (N,C,H,W)
     * @param shape                 the 4D shape of <b>base</b>.
     * @param result                the array to populate with resulting values.
     * @param broadcastDims         the dimension(s) to broadcast over. 
     */
    // NOTE: THIS FUNCTION IS PARTIALLY GENERATED BY CLAUDE.AI
    protected static void broadcastSubtract(
        float[] base, 
        float[] subtractor, 
        int[] shape, 
        float[] result,
        int... broadcastDims
    ) {
        int numDims = 4;
        if (shape.length != numDims) {
            throw new IllegalArgumentException(
                "Incorrect length of shape. Expected: " 
                + numDims + ". Got: " + shape.length);
        }   
        int numElements = shape[0] * shape[1] * shape[2] * shape[3];
        
        Set<Integer> broadcastSet = Arrays
            .stream(broadcastDims)
            .boxed()
            .collect(Collectors.toSet());
        
        // Calculate strides for base array
        int[] strides = new int[numDims];
        strides[numDims - 1] = 1;
        for (int i = numDims - 2; i >= 0; i--) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        
        // Calculate strides for subtractor (0 for non-broadcast dims)
        int[] sStrides = new int[numDims];
        sStrides[numDims - 1] = broadcastSet.contains(numDims - 1) ? 1 : 0;
        for (int i = numDims - 2; i >= 0; i--) {
            sStrides[i] = broadcastSet.contains(i) ? 
                sStrides[i + 1] * (broadcastSet.contains(i + 1) ? shape[i + 1] : 1) : 0;
        }
        
        IntStream.range(0, numElements).parallel().forEach(flatIdx -> {
            int sIdx = 0, remaining = flatIdx;
            for (int i = 0; i < numDims; i++) {
                int idx = remaining / strides[i];
                sIdx += idx * sStrides[i];
                remaining %= strides[i];
            }
            result[flatIdx] = base[flatIdx] - subtractor[sIdx];
        });
    }
    
    /**
     * Broadcast multiply a multiplier array over a base array.
     * @param base                  the 4D base array.
     * @param multiplier            the array to broadcast over <b>base</b>.
     * All non-broadcast dimensions in <b>multiplier</b> should be one, e.g. (N,1,1,1) over (N,C,H,W)
     * @param shape                 the 4D shape of <b>base</b>.
     * @param result                the array to populate with resulting values.
     * @param broadcastDims         the dimension(s) to broadcast over. 
     */
    // NOTE: THIS FUNCTION IS PARTIALLY GENERATED BY CLAUDE.AI
    protected static void broadcastMultiply(
        float[] base, 
        float[] multiplier, 
        int[] shape, 
        float[] result,
        int... broadcastDims
    ) {
        int numDims = 4;
        if (shape.length != numDims) {
            throw new IllegalArgumentException(
                "Incorrect length of shape. Expected: " 
                + numDims + ". Got: " + shape.length);
        }   
        int numElements = shape[0] * shape[1] * shape[2] * shape[3];
        
        Set<Integer> broadcastSet = Arrays
            .stream(broadcastDims)
            .boxed()
            .collect(Collectors.toSet());
        
        // Calculate strides for base array
        int[] strides = new int[numDims];
        strides[numDims - 1] = 1;
        for (int i = numDims - 2; i >= 0; i--) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        
        // Calculate strides for multiplier (0 for non-broadcast dims)
        int[] mStrides = new int[numDims];
        mStrides[numDims - 1] = broadcastSet.contains(numDims - 1) ? 1 : 0;
        for (int i = numDims - 2; i >= 0; i--) {
            mStrides[i] = broadcastSet.contains(i) ? 
                mStrides[i + 1] * (broadcastSet.contains(i + 1) ? shape[i + 1] : 1) : 0;
        }
        
        IntStream.range(0, numElements).parallel().forEach(flatIdx -> {
            int mIdx = 0, remaining = flatIdx;
            for (int i = 0; i < numDims; i++) {
                int idx = remaining / strides[i];
                mIdx += idx * mStrides[i];
                remaining %= strides[i];
            }
            result[flatIdx] = base[flatIdx] * multiplier[mIdx];
        });
    }

    /**
     * Broadcast divide a divisor array from a base array.
     * @param base                  the 4D base array.
     * @param divisor               the array to broadcast over <b>base</b>.
     * All non-broadcast dimensions in <b>divisor</b> should be one, e.g. (N,1,1,1) over (N,C,H,W)
     * @param shape                 the 4D shape of <b>base</b>.
     * @param result                the array to populate with resulting values.
     * @param broadcastDims         the dimension(s) to broadcast over. 
     */
    // NOTE: THIS FUNCTION IS PARTIALLY GENERATED BY CLAUDE.AI
    protected static void broadcastDivide(
        float[] base, 
        float[] divisor, 
        int[] shape, 
        float[] result,
        int... broadcastDims
    ) {
        int numDims = 4;
        if (shape.length != numDims) {
            throw new IllegalArgumentException(
                "Incorrect length of shape. Expected: " 
                + numDims + ". Got: " + shape.length);
        }   
        int numElements = shape[0] * shape[1] * shape[2] * shape[3];
        
        Set<Integer> broadcastSet = Arrays
            .stream(broadcastDims)
            .boxed()
            .collect(Collectors.toSet());
        
        // Calculate strides for base array
        int[] strides = new int[numDims];
        strides[numDims - 1] = 1;
        for (int i = numDims - 2; i >= 0; i--) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        
        // Calculate strides for divisor (0 for non-broadcast dims)
        int[] dStrides = new int[numDims];
        dStrides[numDims - 1] = broadcastSet.contains(numDims - 1) ? 1 : 0;
        for (int i = numDims - 2; i >= 0; i--) {
            dStrides[i] = broadcastSet.contains(i) ? 
                dStrides[i + 1] * (broadcastSet.contains(i + 1) ? shape[i + 1] : 1) : 0;
        }
        
        IntStream.range(0, numElements).parallel().forEach(flatIdx -> {
            int dIdx = 0, remaining = flatIdx;
            for (int i = 0; i < numDims; i++) {
                int idx = remaining / strides[i];
                dIdx += idx * dStrides[i];
                remaining %= strides[i];
            }
            result[flatIdx] = base[flatIdx] / divisor[dIdx];
        });
    }

    /**
     * Broadcast sqrt across every item.
     * @param input                 the array to sqrt.
     * @param result                the array to populate with resulting values.
     */
    protected static void broadcastSqrt(float[] input, float[] result) {
        int length = input.length;

        IntStream.range(0, length).parallel().forEach(i -> {
            result[i] = (float)(Math.sqrt(input[i]));
        });
    }

    /**
     * Broadcast 1 / x across every item x.
     * @param input                 the array to take the reciprocal of.
     * @param result                the array to populate with resulting values.
     */
    protected static void broadcastReciprocal(float[] input, float[] result) {
        int length = input.length;

        IntStream.range(0, length).parallel().forEach(i -> {
            result[i] = 1.0f / input[i];
        });
    }
}
