package jflow.data;

import java.util.stream.IntStream;

class MatrixTranspose {
    /**
     * Transpose a 2D matrix, swapping height and width.
     * @param input                 the array to transpose.
     * @param oldHeight             the height dimension of input.
     * @param oldWidth              the width dimension of input.
     * @param result                the array to populate with resulting values.
     */
    public static void transpose2DMatrix(
        float[] input, 
        int oldHeight, 
        int oldWidth, 
        float[] result
    ) {   
        int newWidth = oldHeight;
    
        IntStream.range(0, oldHeight).parallel().forEach(row -> {
            for (int col = 0; col < oldWidth; col++) {
                int oldIndex = row * oldWidth + col;
                int newIndex = col * newWidth + row;
                result[newIndex] = input[oldIndex];
            }
        });
    }

    /**
     * Transpose a 3D matrix, preserving the batch dimension 
     * and swapping height and width.
     * @param input                 the array to transpose.
     * @param batch                 the batch dimension of input.
     * @param oldHeight             the height dimension of input.
     * @param oldWidth              the width dimension of input.
     * @param result                the array to populate with resulting values.
     */
    public static void transpose3DMatrix(
        float[] input,
        int batch,
        int oldHeight,
        int oldWidth,
        float[] result
    ) {
        int newHeight = oldWidth;
        int newWidth = oldHeight;
        int oldPerBatch = oldHeight * oldWidth;
        int newPerBatch = newHeight * newWidth;
        
        IntStream.range(0, batch).parallel().forEach(b -> {
            for (int h = 0; h < oldHeight; h++) {
                for (int w = 0; w < oldWidth; w++) {
                    int oldIndex = b * oldPerBatch + h * oldWidth + w;
                    int newIndex = b * newPerBatch + w * oldHeight + h;
                    result[newIndex] = input[oldIndex];
                }
            }
        });
    }


    /**
     * Transpose a 4D matrix by rearranging dimensions according to a particular order.
     * @param input                        the array to transpose.
     * @param oldLength                    the first dimension of input.
     * @param oldChannels                  the second dimension of input.
     * @param oldWidth                     the third dimension of input.
     * @param oldHeight                    the fourth dimension of input.
     * @param axis1                        the dimension to use as the first dimension (0=N, 1=C, 2=H, 3=W).
     * @param axis2                        the dimension to use as the second dimension (0=N, 1=C, 2=H, 3=W).
     * @param axis3                        the dimension to use as the third dimension (0=N, 1=C, 2=H, 3=W).
     * @param axis4                        the dimension to use as the fourth dimension (0=N, 1=C, 2=H, 3=W).
     * @param result                       the array to populate with resulting values.
     * @throws IllegalArgumentException    If axis values are not a permuation of (0, 1, 2, 3).
     */
    // NOTE: THIS FUNCTION IS PARTIALLY GENERATED BY CLAUDE.AI
    public static void transpose4DMatrixByDims(
        float[] input,
        int oldLength,
        int oldChannels,
        int oldHeight,
        int oldWidth,
        int axis1, 
        int axis2, 
        int axis3, 
        int axis4,
        float[] result
    ) {
        int[] axes = {axis1, axis2, axis3, axis4};
        /// Check input values
        boolean[] used = new boolean[4];
        for (int axis : axes) {
            if (axis < 0 || axis > 3) {
                throw new IllegalArgumentException("Axis values must be between 0 and 3 inclusive");
            }
            if (used[axis]) {
                throw new IllegalArgumentException("Axis values must be a permutation of 0, 1, 2, 3");
            }
            used[axis] = true;
        }

        int[] dims = {oldLength, oldChannels, oldHeight, oldWidth};
        
        // Calculate new dimensions after transposition
        int newChannels = dims[axis2];
        int newHeight = dims[axis3];
        int newWidth = dims[axis4];
    
        
        // Pre-calculate the permutation mapping for faster index calculation
        
        // Pre-calculate strides for both original and new array
        int[] oldStrides = new int[4];
        oldStrides[3] = 1;                                  
        oldStrides[2] = oldWidth;                           
        oldStrides[1] = oldHeight * oldWidth;                
        oldStrides[0] = oldChannels * oldHeight * oldWidth;     
        
        int[] newStrides = new int[4];
        newStrides[3] = 1;                                   
        newStrides[2] = newWidth;                            
        newStrides[1] = newHeight * newWidth;                
        newStrides[0] = newChannels * newHeight * newWidth;
        
        final int totalElements = oldLength * oldChannels * oldHeight * oldWidth;
        final int THRESHOLD = 1024;
        
        // For small matrices, use a single-threaded approach
        if (totalElements <= THRESHOLD) {
            transposeSequential(input, axes, dims,oldStrides, newStrides,result);
        } else {
            int numThreads = Runtime.getRuntime().availableProcessors();
            int blockSize = Math.max(1, totalElements / (numThreads * 4));
            
            IntStream.range(0, (totalElements + blockSize - 1) / blockSize)
                .parallel()
                .forEach(block -> {
                    int start = block * blockSize;
                    int end = Math.min(start + blockSize, totalElements);
                    transposeBlock(input, axes, dims, oldStrides, newStrides, start, end, result);
                });
        }
    }

    /**
     * Sequential transposition for small matrices
     */
    // NOTE: THIS FUNCTION IS PARTIALLY GENERATED BY CLAUDE.AI
    private static void transposeSequential(
        float[] input, 
        int[] axes, int[] oldDims, 
        int[] oldStrides, 
        int[] newStrides,
        float[] result
    ) {
        int length = oldDims[0];
        int channels = oldDims[1];
        int height = oldDims[2];
        int width = oldDims[3];
        
        for (int n = 0; n < length; n++) {
            for (int c = 0; c < channels; c++) {
                for (int h = 0; h < height; h++) {
                    for (int w = 0; w < width; w++) {
                        // Original coordinates
                        int[] coords = {n, c, h, w};
                        
                        // Calculate original index
                        int originalIndex = n * oldStrides[0] + c * oldStrides[1] + 
                                        h * oldStrides[2] + w * oldStrides[3];
                        
                        // Calculate new coordinates after transposition
                        int newN = coords[axes[0]];
                        int newC = coords[axes[1]];
                        int newH = coords[axes[2]];
                        int newW = coords[axes[3]];
                        
                        // Calculate new index directly
                        int newIndex = newN * newStrides[0] + newC * newStrides[1] + 
                                    newH * newStrides[2] + newW * newStrides[3];
                        
                        // Copy the value
                        result[newIndex] = input[originalIndex];
                    }
                }
            }
        }
    }

    // NOTE: THIS FUNCTION IS PARTIALLY GENERATED BY CLAUDE.AI
    private static void transposeBlock(
        float[] input, 
        int[] axes, 
        int[] oldDims, 
        int[] oldStrides, 
        int[] newStrides, 
        int startIdx, 
        int endIdx,
        float[] result
    ) {
        // Pre-calculated values for the innermost loop
        int axis1 = axes[0], axis2 = axes[1], axis3 = axes[2], axis4 = axes[3];
        
        // Get the actual dimensions for bounds checking
        int maxN = oldDims[0], maxC = oldDims[1], maxH = oldDims[2], maxW = oldDims[3];
        
        // Get a linear index and convert to 4D coordinates
        for (int linearIdx = startIdx; linearIdx < endIdx; linearIdx++) {
            // Convert linear index to NCHW coordinates
            int remaining = linearIdx;
            int n = remaining / oldStrides[0];
            remaining %= oldStrides[0];
            int c = remaining / oldStrides[1];
            remaining %= oldStrides[1];  
            int h = remaining / oldStrides[2];
            int w = remaining % oldStrides[2];
            
            // Bounds check to prevent IndexOutOfBounds
            if (n >= maxN || c >= maxC || h >= maxH || w >= maxW) {
                continue; // Skip invalid coordinates
            }
            
            // Original coordinates
            int[] oldCoords = {n, c, h, w};
            
            // Map to new coordinates based on axis permutation
            int newN = oldCoords[axis1];
            int newC = oldCoords[axis2];
            int newH = oldCoords[axis3]; 
            int newW = oldCoords[axis4];
            
            // Calculate new index
            int newIdx = newN * newStrides[0] + newC * newStrides[1] + 
                        newH * newStrides[2] + newW * newStrides[3];
            
            // Bounds check for output array
            if (newIdx >= 0 && newIdx < result.length) {
                // Copy the value 
                result[newIdx] = input[linearIdx];
            }
        }
    }
}
